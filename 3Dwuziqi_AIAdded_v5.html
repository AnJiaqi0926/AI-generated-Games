<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三维五子棋</title>
    <style>
        /* 所有样式保持不变 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            overflow: hidden;
            height: 100vh;
        }
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #header {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        #header h1 {
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #header p {
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.5;
        }
        #content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #game-container {
            flex: 3;
            position: relative;
        }
        #ui-panel {
            flex: 1;
            max-width: 350px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #game-info {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }
        h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }
        .btn {
            padding: 10px 15px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            margin: 5px;
        }
        .btn:hover {
            background: #357ae8;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-danger {
            background: #e74c3c;
        }
        .btn-danger:hover {
            background: #c0392b;
        }
        .btn-success {
            background: #2ecc71;
        }
        .btn-success:hover {
            background: #27ae60;
        }
        #status {
            font-size: 1.2rem;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        #coordinates {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #ccc;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        .rules {
            margin-top: 20px;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        .rules h3 {
            margin: 10px 0 5px 0;
            color: #4a90e2;
        }
        .rules ul {
            padding-left: 20px;
        }
        .rules li {
            margin-bottom: 5px;
        }
        #current-player {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .player-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .black {
            background: #000;
            border: 1px solid #fff;
        }
        .white {
            background: #fff;
            border: 1px solid #000;
        }
        .coordinate-input {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        .coordinate-input input {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
        }
        .coordinate-input input:focus {
            outline: none;
            border-color: #4a90e2;
        }
        .placement-mode {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .mode-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mode-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }
        .layer-info {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        .layer-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .layer-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .layer-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .board-size-control {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .board-size-control input {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
        }
        .key-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }
        .key-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            text-align: center;
            font-size: 0.8rem;
        }
        .key-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }
        #instructions {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #ccc;
        }
        .winning-line {
            position: absolute;
            background: rgba(255, 215, 0, 0.7);
            z-index: 100;
        }
        .ai-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .ai-options {
            display: flex;
            gap: 10px;
        }
        .ai-options select {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: rgba(255, 255, 255, 0.1);
            color: white; /* 修复选择框字体颜色 */
        }
        /* 修复选择框选项背景色 */
        .ai-options option {
            background: #333;
            color: white;
        }
        
        /* 新增：结算画面样式 */
        #game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            flex-direction: column;
        }
        
        #result-container {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.3);
            animation: pulse 2s infinite;
            max-width: 600px;
            width: 80%;
            position: relative;
            z-index: 1002;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        #result-title {
            font-size: 4rem;
            margin-bottom: 20px;
            text-shadow: 3px 3px 10px rgba(0, 0, 0, 0.7);
        }
        
        #result-subtitle {
            font-size: 2rem;
            margin-bottom: 30px;
        }
        
        #winning-info {
            font-size: 1.5rem;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }
        
        #result-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 20px;
        }
        
        .result-btn {
            padding: 15px 30px;
            font-size: 1.2rem;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        
        #continue-btn {
            background: #2ecc71;
            color: white;
        }
        
        #continue-btn:hover {
            background: #27ae60;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(46, 204, 113, 0.4);
        }
        
        #new-game-btn {
            background: #4a90e2;
            color: white;
        }
        
        #new-game-btn:hover {
            background: #357ae8;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(74, 144, 226, 0.4);
        }
        
        /* 烟花效果 */
        .firework {
            position: absolute;
            width: 5px;
            height: 5px;
            border-radius: 50%;
            box-shadow: 0 0 10px #fff;
            z-index: 1001;
        }
        
        /* 阴雨效果 */
        .raindrop {
            position: absolute;
            width: 2px;
            height: 20px;
            background: linear-gradient(to bottom, transparent, #3498db);
            z-index: 1001;
        }
        
        @media (max-width: 768px) {
            #content {
                flex-direction: column;
            }
            #ui-panel {
                max-width: 100%;
            }
            #result-container {
                padding: 20px;
                width: 90%;
            }
            #result-title {
                font-size: 2.5rem;
            }
            #result-subtitle {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>三维五子棋</h1>
            <p>在三维空间中连成五个或以上相同颜色的棋子即可获胜</p>
        </div>
        <div id="content">
            <div id="game-container">
                <div id="canvas-container"></div>
            </div>
            <div id="ui-panel">
                <div id="game-info">
                    <h2>游戏状态</h2>
                    <div id="status">黑方先行</div>
                    <div id="current-player">
                        <div class="player-indicator black"></div>
                        <span>当前玩家: 黑方</span>
                    </div>
                    <div class="layer-info">
                        <span>当前层: <span id="layer-value">9</span></span>
                        <span>落子模式: <span id="mode-value">坐标输入</span></span>
                    </div>
                    <div id="coordinates">预览位置: (9, 9, 9)</div>
                </div>
                <div id="controls">
                    <div class="control-group">
                        <h2>游戏模式</h2>
                        <div class="ai-controls">
                            <div class="ai-options">
                                <select id="game-mode">
                                    <option value="pvp">玩家 vs 玩家</option>
                                    <option value="pve" selected>玩家 vs AI</option>
                                </select>
                                <select id="ai-difficulty">
                                    <option value="easy">简单</option>
                                    <option value="medium" selected>中等</option>
                                    <option value="hard">困难</option>
                                </select>
                            </div>
                            <div class="ai-options">
                                <select id="player-color">
                                    <option value="black" selected>玩家执黑</option>
                                    <option value="white">玩家执白</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>棋盘设置</h2>
                        <div class="board-size-control">
                            <input type="number" id="board-size-input" min="5" max="21" value="15">
                            <button id="set-board-size" class="btn">设置棋盘大小</button>
                        </div>
                        <div style="font-size: 0.9rem; color: #ccc; margin-top: 5px;">
                            棋盘大小: 5x5x5 到 21x21x21
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>坐标输入落子</h2>
                        <div id="coord-input" class="coordinate-input">
                            <input type="number" id="x-input" min="0" max="14" placeholder="X" value="7">
                            <input type="number" id="y-input" min="0" max="14" placeholder="Y" value="7">
                            <input type="number" id="z-input" min="0" max="14" placeholder="Z" value="7">
                            <button id="place-btn" class="btn">落子</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>位置微调</h2>
                        <div class="key-controls">
                            <div class="key-btn" id="key-up">↑ Y+</div>
                            <div class="key-btn" id="key-down">↓ Y-</div>
                            <div class="key-btn" id="key-layer-up">层+</div>
                            <div class="key-btn" id="key-left">← X-</div>
                            <div class="key-btn" id="key-center">确认</div>
                            <div class="key-btn" id="key-right">→ X+</div>
                            <div class="key-btn" id="key-front">前 Z+</div>
                            <div class="key-btn" id="key-back">后 Z-</div>
                            <div class="key-btn" id="key-layer-down">层-</div>
                        </div>
                        <div style="font-size: 0.9rem; color: #ccc; margin-top: 5px;">
                            点击按钮或使用键盘按键微调位置
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>层控制（辅助查看）</h2>
                        <div class="slider-container">
                            <label for="layer-slider">层数: <span id="layer-display">7</span></label>
                            <input type="range" id="layer-slider" min="0" max="14" value="7">
                        </div>
                        <div class="layer-controls">
                            <button id="prev-layer" class="layer-btn">上一层</button>
                            <button id="next-layer" class="layer-btn">下一层</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>游戏控制</h2>
                        <button id="new-game" class="btn btn-success">新游戏</button>
                        <button id="pass-turn" class="btn">跳过回合</button>
                        <button id="resign" class="btn btn-danger">认输</button>
                        <button id="reset-view" class="btn">重置视角</button>
                        <button id="toggle-drag" class="btn">拖动模式: 关闭</button>
                    </div>
                    
                    <div class="rules">
                        <h2>三维五子棋规则</h2>
                        <h3>基本规则</h3>
                        <ul>
                            <li>棋盘为NxNxN的三维网格</li>
                            <li>黑白双方交替落子</li>
                            <li>先在任意直线方向连成五个或以上相同颜色棋子的一方获胜</li>
                        </ul>
                        <h3>获胜条件</h3>
                        <ul>
                            <li>在任意直线方向（包括三维对角线）连成五个或以上相同颜色的棋子</li>
                            <li>方向包括：水平、垂直、对角线（平面和空间对角线）</li>
                        </ul>
                        <h3>特殊规则</h3>
                        <ul>
                            <li>无禁手规则</li>
                            <li>超过五个棋子连线同样获胜</li>
                        </ul>
                    </div>
                    <div id="instructions">
                        <p>操作说明：</p>
                        <p>• 鼠标拖拽：旋转视角</p>
                        <p>• 鼠标滚轮：缩放</p>
                        <p>• 中键拖拽：平移棋盘</p>
                        <p>• 使用坐标输入模式落子</p>
                        <p>• 黑方控制：W(X+1)/S(X-1)/A(Z+1)/D(Z-1)/Q(Y+1)/E(Y-1)</p>
                        <p>• 白方控制：↑(X+1)/↓(X-1)/←(Z+1)/→(Z-1)/PageUp(Y+1)/PageDown(Y-1)</p>
                        <p>• 双方均使用Enter键确认落子</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- 新增：结算画面 -->
    <div id="game-overlay">
        <div id="result-container">
            <div id="result-title"></div>
            <div id="result-subtitle"></div>
            <div id="winning-info"></div>
            <div id="result-buttons">
                <button id="continue-btn" class="result-btn">继续观看</button>
                <button id="new-game-btn" class="result-btn">新游戏</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // AI类（保持不变）
        class GomokuAI {
            constructor(difficulty = 'medium', playerColor = 1) {
                this.difficulty = difficulty;
                this.playerColor = playerColor;
                this.aiColor = 3 - playerColor;
                
                // 根据难度设置搜索深度
                switch(difficulty) {
                    case 'easy':
                        this.searchDepth = 1;
                        break;
                    case 'medium':
                        this.searchDepth = 2;
                        break;
                    case 'hard':
                        this.searchDepth = 3;
                        break;
                }
            }
            
            // 获取最佳移动
            getBestMove(board, boardSize) {
                let bestScore = -Infinity;
                let bestMove = null;
                
                // 获取所有可能的移动
                const possibleMoves = this.getPossibleMoves(board, boardSize);
                
                // 如果没有可能的移动，返回null
                if (possibleMoves.length === 0) {
                    return null;
                }
                
                // 根据难度限制搜索的移动数量
                let movesToSearch = possibleMoves;
                if (this.difficulty !== 'hard' && possibleMoves.length > 20) {
                    // 按启发式分数排序并取前几个
                    movesToSearch = possibleMoves
                        .sort((a, b) => this.evaluateMove(board, boardSize, b.x, b.y, b.z) - 
                                        this.evaluateMove(board, boardSize, a.x, a.y, a.z))
                        .slice(0, 20);
                }
                
                // 对每个可能的移动进行搜索
                for (const move of movesToSearch) {
                    // 模拟移动
                    board[move.x][move.y][move.z] = this.aiColor;
                    
                    // 计算分数
                    let score;
                    if (this.searchDepth > 1) {
                        score = this.minimax(board, boardSize, this.searchDepth - 1, false, -Infinity, Infinity);
                    } else {
                        score = this.evaluateBoard(board, boardSize);
                    }
                    
                    // 撤销移动
                    board[move.x][move.y][move.z] = 0;
                    
                    // 更新最佳移动
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }
            
            // 获取所有可能的移动（只考虑有棋子相邻的位置以提高效率）
            getPossibleMoves(board, boardSize) {
                const moves = [];
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 首先检查中心区域
                const center = Math.floor(boardSize / 2);
                const searchRadius = Math.min(3, Math.floor(boardSize / 2));
                
                for (let x = Math.max(0, center - searchRadius); x <= Math.min(boardSize - 1, center + searchRadius); x++) {
                    for (let y = Math.max(0, center - searchRadius); y <= Math.min(boardSize - 1, center + searchRadius); y++) {
                        for (let z = Math.max(0, center - searchRadius); z <= Math.min(boardSize - 1, center + searchRadius); z++) {
                            if (board[x][y][z] === 0) {
                                // 检查是否有棋子相邻
                                for (const dir of directions) {
                                    const nx = x + dir.dx;
                                    const ny = y + dir.dy;
                                    const nz = z + dir.dz;
                                    
                                    if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && nz >= 0 && nz < boardSize) {
                                        if (board[nx][ny][nz] !== 0) {
                                            moves.push({x, y, z});
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 如果没有找到任何移动，返回棋盘中心
                if (moves.length === 0) {
                    moves.push({x: center, y: center, z: center});
                }
                
                return moves;
            }
            
            // Minimax算法
            minimax(board, boardSize, depth, isMaximizing, alpha, beta) {
                // 检查游戏是否结束
                const gameResult = this.checkGameResult(board, boardSize);
                if (gameResult !== 0 || depth === 0) {
                    return this.evaluateBoard(board, boardSize);
                }
                
                if (isMaximizing) {
                    let maxScore = -Infinity;
                    const possibleMoves = this.getPossibleMoves(board, boardSize);
                    
                    for (const move of possibleMoves) {
                        board[move.x][move.y][move.z] = this.aiColor;
                        const score = this.minimax(board, boardSize, depth - 1, false, alpha, beta);
                        board[move.x][move.y][move.z] = 0;
                        
                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        
                        if (beta <= alpha) {
                            break; // Beta剪枝
                        }
                    }
                    
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    const possibleMoves = this.getPossibleMoves(board, boardSize);
                    
                    for (const move of possibleMoves) {
                        board[move.x][move.y][move.z] = this.playerColor;
                        const score = this.minimax(board, boardSize, depth - 1, true, alpha, beta);
                        board[move.x][move.y][move.z] = 0;
                        
                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        
                        if (beta <= alpha) {
                            break; // Alpha剪枝
                        }
                    }
                    
                    return minScore;
                }
            }
            
            // 评估棋盘状态
            evaluateBoard(board, boardSize) {
                let score = 0;
                
                // 检查所有可能的方向
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 遍历所有位置
                for (let x = 0; x < boardSize; x++) {
                    for (let y = 0; y < boardSize; y++) {
                        for (let z = 0; z < boardSize; z++) {
                            if (board[x][y][z] !== 0) {
                                // 对每个方向评估
                                for (const dir of directions) {
                                    const lineScore = this.evaluateLine(board, boardSize, x, y, z, dir.dx, dir.dy, dir.dz);
                                    if (board[x][y][z] === this.aiColor) {
                                        score += lineScore;
                                    } else {
                                        score -= lineScore * 1.2; // 防守比进攻更重要
                                    }
                                }
                            }
                        }
                    }
                }
                
                return score;
            }
            
            // 评估单个移动
            evaluateMove(board, boardSize, x, y, z) {
                if (board[x][y][z] !== 0) return -Infinity;
                
                let score = 0;
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 模拟放置棋子
                board[x][y][z] = this.aiColor;
                
                // 评估这个位置
                for (const dir of directions) {
                    score += this.evaluateLine(board, boardSize, x, y, z, dir.dx, dir.dy, dir.dz);
                }
                
                // 撤销模拟
                board[x][y][z] = 0;
                
                return score;
            }
            
            // 评估一条线上的棋子
            evaluateLine(board, boardSize, x, y, z, dx, dy, dz) {
                const player = board[x][y][z];
                if (player === 0) return 0;
                
                let count = 1; // 当前位置的棋子
                let openEnds = 0;
                
                // 正向检查
                let nx = x + dx;
                let ny = y + dy;
                let nz = z + dz;
                
                while (nx >= 0 && nx < boardSize && 
                       ny >= 0 && ny < boardSize && 
                       nz >= 0 && nz < boardSize &&
                       board[nx][ny][nz] === player) {
                    count++;
                    nx += dx;
                    ny += dy;
                    nz += dz;
                }
                
                // 检查正向是否开放
                if (nx >= 0 && nx < boardSize && 
                    ny >= 0 && ny < boardSize && 
                    nz >= 0 && nz < boardSize &&
                    board[nx][ny][nz] === 0) {
                    openEnds++;
                }
                
                // 反向检查
                nx = x - dx;
                ny = y - dy;
                nz = z - dz;
                
                while (nx >= 0 && nx < boardSize && 
                       ny >= 0 && ny < boardSize && 
                       nz >= 0 && nz < boardSize &&
                       board[nx][ny][nz] === player) {
                    count++;
                    nx -= dx;
                    ny -= dy;
                    nz -= dz;
                }
                
                // 检查反向是否开放
                if (nx >= 0 && nx < boardSize && 
                    ny >= 0 && ny < boardSize && 
                    nz >= 0 && nz < boardSize &&
                    board[nx][ny][nz] === 0) {
                    openEnds++;
                }
                
                // 根据连子数量和开放程度评分
                if (count >= 5) {
                    return 100000; // 获胜
                } else if (count === 4) {
                    if (openEnds === 2) return 10000; // 活四
                    if (openEnds === 1) return 1000;  // 冲四
                } else if (count === 3) {
                    if (openEnds === 2) return 1000;  // 活三
                    if (openEnds === 1) return 100;   // 冲三
                } else if (count === 2) {
                    if (openEnds === 2) return 100;   // 活二
                    if (openEnds === 1) return 10;    // 冲二
                } else if (count === 1) {
                    if (openEnds === 2) return 10;    // 活一
                    if (openEnds === 1) return 1;     // 冲一
                }
                
                return 0;
            }
            
            // 检查游戏结果
            checkGameResult(board, boardSize) {
                // 遍历所有位置检查是否有五连子
                for (let x = 0; x < boardSize; x++) {
                    for (let y = 0; y < boardSize; y++) {
                        for (let z = 0; z < boardSize; z++) {
                            if (board[x][y][z] !== 0) {
                                if (this.checkWinFromPosition(board, boardSize, x, y, z)) {
                                    return board[x][y][z];
                                }
                            }
                        }
                    }
                }
                
                return 0; // 游戏继续
            }
            
            // 从指定位置检查是否获胜
            checkWinFromPosition(board, boardSize, x, y, z) {
                const player = board[x][y][z];
                if (player === 0) return false;
                
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                for (const dir of directions) {
                    let count = 1;
                    
                    // 正向检查
                    let nx = x + dir.dx;
                    let ny = y + dir.dy;
                    let nz = z + dir.dz;
                    
                    while (nx >= 0 && nx < boardSize && 
                           ny >= 0 && ny < boardSize && 
                           nz >= 0 && nz < boardSize &&
                           board[nx][ny][nz] === player) {
                        count++;
                        nx += dir.dx;
                        ny += dir.dy;
                        nz += dir.dz;
                    }
                    
                    // 反向检查
                    nx = x - dir.dx;
                    ny = y - dir.dy;
                    nz = z - dir.dz;
                    
                    while (nx >= 0 && nx < boardSize && 
                           ny >= 0 && ny < boardSize && 
                           nz >= 0 && nz < boardSize &&
                           board[nx][ny][nz] === player) {
                        count++;
                        nx -= dir.dx;
                        ny -= dir.dy;
                        nz -= dir.dz;
                    }
                    
                    if (count >= 5) {
                        return true;
                    }
                }
                
                return false;
            }
        }

        // 游戏主类
        class ThreeDGomoku {
            constructor() {
                this.boardSize = 15;
                this.currentLayer = Math.floor(this.boardSize / 2);
                this.currentPlayer = 1; // 1: 黑, 2: 白
                this.placementMode = 'coord'; // 现在只有坐标输入模式
                this.dragEnabled = false;
                this.previewPosition = {
                    x: Math.floor(this.boardSize / 2),
                    y: Math.floor(this.boardSize / 2),
                    z: Math.floor(this.boardSize / 2)
                };
                this.winningLine = null;
                this.gameMode = 'pve'; // 'pvp' 或 'pve'
                this.aiDifficulty = 'medium';
                this.playerColor = 1; // 1: 黑, 2: 白
                this.ai = new GomokuAI(this.aiDifficulty, this.playerColor);
                
                // 新增：存储获胜棋子信息
                this.winningStones = []; // 存储获胜棋子对象
                this.winningStoneAnimationTime = 0; // 动画时间
                this.winningAnimationActive = false; // 动画是否激活
                
                this.initThreeJS();
                this.createBoard();
                this.setupEventListeners();
                this.updateUI();
                this.updatePreview();
                
                // 开始动画循环
                this.animate();
            }
            
            // 创建空棋盘
            createEmptyBoard() {
                const board = [];
                for (let x = 0; x < this.boardSize; x++) {
                    board[x] = [];
                    for (let y = 0; y < this.boardSize; y++) {
                        board[x][y] = [];
                        for (let z = 0; z < this.boardSize; z++) {
                            board[x][y][z] = 0;
                        }
                    }
                }
                return board;
            }
            
            // 初始化Three.js场景
            initThreeJS() {
                // 场景
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);
                
                // 相机
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(20, 15, 20);
                
                // 渲染器
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                // 控制器
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // 光源
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 15);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // 点光源 - 用于增强获胜棋子的发光效果
                this.pointLight = new THREE.PointLight(0xffffff, 1, 50);
                this.pointLight.position.set(0, 10, 0);
                this.scene.add(this.pointLight);
                
                // 辅助网格和坐标轴
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                this.scene.add(gridHelper);
                
                const axesHelper = new THREE.AxesHelper(5);
                this.scene.add(axesHelper);
                
                // 窗口大小调整
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            // 创建棋盘
            createBoard() {
                // 清除现有棋盘
                if (this.boardGroup) {
                    this.scene.remove(this.boardGroup);
                }
                if (this.stoneGroup) {
                    this.scene.remove(this.stoneGroup);
                }
                if (this.layerIndicator) {
                    this.scene.remove(this.layerIndicator);
                }
                if (this.previewStone) {
                    this.scene.remove(this.previewStone);
                }
                if (this.winningLine) {
                    this.scene.remove(this.winningLine);
                    this.winningLine = null;
                }
                
                // 清除获胜棋子动画
                this.winningStones = [];
                this.winningAnimationActive = false;
                
                this.boardGroup = new THREE.Group();
                this.stoneGroup = new THREE.Group();
                this.scene.add(this.boardGroup);
                this.scene.add(this.stoneGroup);
                
                // 创建棋盘线
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
                const offset = (this.boardSize - 1) / 2;
                
                // X方向线
                for (let x = 0; x < this.boardSize; x++) {
                    for (let z = 0; z < this.boardSize; z++) {
                        const points = [];
                        points.push(new THREE.Vector3(x - offset, 0, z - offset));
                        points.push(new THREE.Vector3(x - offset, this.boardSize - 1, z - offset));
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, lineMaterial);
                        this.boardGroup.add(line);
                    }
                }
                
                // Y方向线
                for (let y = 0; y < this.boardSize; y++) {
                    for (let z = 0; z < this.boardSize; z++) {
                        const points = [];
                        points.push(new THREE.Vector3(-offset, y, z - offset));
                        points.push(new THREE.Vector3(offset, y, z - offset));
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, lineMaterial);
                        this.boardGroup.add(line);
                    }
                }
                
                // Z方向线
                for (let x = 0; x < this.boardSize; x++) {
                    for (let y = 0; y < this.boardSize; y++) {
                        const points = [];
                        points.push(new THREE.Vector3(x - offset, y, -offset));
                        points.push(new THREE.Vector3(x - offset, y, offset));
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, lineMaterial);
                        this.boardGroup.add(line);
                    }
                }
                
                // 创建交叉点标记
                const dotGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
                
                for (let x = 0; x < this.boardSize; x++) {
                    for (let y = 0; y < this.boardSize; y++) {
                        for (let z = 0; z < this.boardSize; z++) {
                            // 只在特定位置放置标记点，避免过于密集
                            if ((x % 5 === 0 && y % 5 === 0 && z % 5 === 0) || 
                                (x === offset && y === offset && z === offset)) {
                                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                                dot.position.set(x - offset, y, z - offset);
                                this.boardGroup.add(dot);
                            }
                        }
                    }
                }
                
                // 创建当前层指示器
                this.layerIndicator = new THREE.Group();
                this.updateLayerIndicator();
                this.scene.add(this.layerIndicator);
                
                // 创建预览棋子
                const previewGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const previewMaterial = new THREE.MeshStandardMaterial({ 
                    color: this.currentPlayer === 1 ? 0x000000 : 0xffffff,
                    roughness: 0.7,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.6
                });
                
                this.previewStone = new THREE.Mesh(previewGeometry, previewMaterial);
                this.updatePreviewPosition();
                this.scene.add(this.previewStone);
                
                // 初始化棋盘状态
                this.board = this.createEmptyBoard();
                this.gameActive = true;
                
                // 如果AI执黑且是PvE模式，让AI先走
                if (this.gameMode === 'pve' && this.playerColor === 2 && this.currentPlayer === 1) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 更新当前层指示器
            updateLayerIndicator() {
                // 清除现有指示器
                while(this.layerIndicator.children.length > 0) { 
                    this.layerIndicator.remove(this.layerIndicator.children[0]); 
                }
                
                const offset = (this.boardSize - 1) / 2;
                
                // 创建当前层的平面
                const planeGeometry = new THREE.PlaneGeometry(this.boardSize, this.boardSize);
                const planeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = Math.PI / 2;
                plane.position.y = this.currentLayer;
                this.layerIndicator.add(plane);
                
                // 更新UI
                document.getElementById('layer-value').textContent = this.currentLayer;
                document.getElementById('layer-display').textContent = this.currentLayer;
                
                // 更新滑块
                document.getElementById('layer-slider').max = this.boardSize - 1;
                document.getElementById('layer-slider').value = this.currentLayer;
            }
            
            // 更新预览位置
            updatePreviewPosition() {
                const offset = (this.boardSize - 1) / 2;
                this.previewStone.position.set(
                    this.previewPosition.x - offset,
                    this.previewPosition.y,
                    this.previewPosition.z - offset
                );
                
                // 更新预览棋子颜色
                this.previewStone.material.color.set(
                    this.currentPlayer === 1 ? 0x000000 : 0xffffff
                );
                
                // 更新坐标显示
                document.getElementById('coordinates').textContent = 
                    `预览位置: (${this.previewPosition.x}, ${this.previewPosition.y}, ${this.previewPosition.z})`;
                
                // 更新输入框
                document.getElementById('x-input').value = this.previewPosition.x;
                document.getElementById('y-input').value = this.previewPosition.y;
                document.getElementById('z-input').value = this.previewPosition.z;
            }
            
            // 放置棋子
            placeStone(x, y, z) {
                if (!this.gameActive) return false;
                
                // 检查位置是否有效
                if (x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize || z < 0 || z >= this.boardSize) {
                    alert('坐标超出范围！有效范围：0-' + (this.boardSize - 1));
                    return false;
                }
                
                // 检查位置是否已有棋子
                if (this.board[x][y][z] !== 0) {
                    alert('该位置已有棋子！');
                    return false;
                }
                
                // 放置棋子
                this.board[x][y][z] = this.currentPlayer;
                
                // 渲染棋子
                this.renderStone(x, y, z);
                
                // 检查是否获胜
                if (this.checkWin(x, y, z)) {
                    this.gameActive = false;
                    const winner = this.currentPlayer === 1 ? '黑方' : '白方';
                    document.getElementById('status').textContent = `${winner}获胜！`;
                    this.updateUI();
                    
                    // 显示结算画面
                    this.showGameResult(this.currentPlayer);
                    
                    // 激活获胜棋子动画
                    this.winningAnimationActive = true;
                    this.winningStoneAnimationTime = 0;
                    
                    return true;
                }
                
                // 切换玩家
                this.currentPlayer = 3 - this.currentPlayer;
                this.updateUI();
                this.updatePreview();
                
                // 如果是PvE模式且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
                
                return true;
            }
            
            // 显示结算画面
            showGameResult(winner) {
                // 获取结算画面元素
                const overlay = document.getElementById('game-overlay');
                const resultTitle = document.getElementById('result-title');
                const resultSubtitle = document.getElementById('result-subtitle');
                const winningInfo = document.getElementById('winning-info');
                
                // 显示结算画面
                overlay.style.display = 'flex';
                
                // 根据游戏模式和胜负显示不同内容
                if (this.gameMode === 'pvp') {
                    // 玩家对玩家模式
                    if (winner === 1) {
                        resultTitle.textContent = '🎉 黑棋获胜！ 🎉';
                        resultSubtitle.textContent = '黑方玩家取得了胜利';
                        this.createFireworks(); // 创建烟花效果
                    } else {
                        resultTitle.textContent = '🎉 白棋获胜！ 🎉';
                        resultSubtitle.textContent = '白方玩家取得了胜利';
                        this.createFireworks(); // 创建烟花效果
                    }
                } else {
                    // 玩家对AI模式
                    const playerWon = (winner === this.playerColor);
                    
                    if (playerWon) {
                        resultTitle.textContent = '🏆 你赢了！ 🏆';
                        resultSubtitle.textContent = '恭喜你战胜了AI！';
                        resultTitle.style.color = '#f1c40f';
                        this.createFireworks(); // 创建烟花效果
                    } else {
                        resultTitle.textContent = '☔ 你输了 ☔';
                        resultSubtitle.textContent = 'AI赢得了胜利';
                        resultTitle.style.color = '#7f8c8d';
                        this.createRain(); // 创建阴雨效果
                    }
                }
                
                // 显示获胜信息
                winningInfo.textContent = `在三维空间中连成了五个${winner === 1 ? '黑色' : '白色'}棋子`;
                
                // 添加连线效果
                this.addWinningLineEffect();
                
                // 自动聚焦到新游戏按钮
                setTimeout(() => {
                    document.getElementById('new-game-btn').focus();
                }, 100);
            }
            
            // 创建烟花效果
            createFireworks() {
                const overlay = document.getElementById('game-overlay');
                const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff', '#ff8800', '#ff0088'];
                
                for (let i = 0; i < 50; i++) {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    
                    // 随机位置
                    const left = Math.random() * 100;
                    const top = Math.random() * 100;
                    
                    // 随机颜色
                    const color = colors[Math.floor(Math.random() * colors.length)];
                    
                    // 随机大小
                    const size = Math.random() * 10 + 5;
                    
                    // 设置样式
                    firework.style.left = `${left}%`;
                    firework.style.top = `${top}%`;
                    firework.style.width = `${size}px`;
                    firework.style.height = `${size}px`;
                    firework.style.backgroundColor = color;
                    firework.style.boxShadow = `0 0 ${size}px ${color}`;
                    
                    // 随机动画
                    const duration = Math.random() * 2 + 1;
                    const delay = Math.random() * 2;
                    
                    firework.style.animation = `
                        fireworkAnimation ${duration}s ease-out ${delay}s infinite alternate
                    `;
                    
                    // 添加到页面
                    overlay.appendChild(firework);
                    
                    // 动态创建CSS动画
                    if (!document.getElementById('firework-animation')) {
                        const style = document.createElement('style');
                        style.id = 'firework-animation';
                        style.textContent = `
                            @keyframes fireworkAnimation {
                                0% {
                                    transform: scale(0.1) translateY(0);
                                    opacity: 1;
                                }
                                50% {
                                    opacity: 1;
                                }
                                100% {
                                    transform: scale(1) translateY(-100px);
                                    opacity: 0;
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
            }
            
            // 创建阴雨效果
            createRain() {
                const overlay = document.getElementById('game-overlay');
                
                for (let i = 0; i < 100; i++) {
                    const raindrop = document.createElement('div');
                    raindrop.className = 'raindrop';
                    
                    // 随机位置
                    const left = Math.random() * 100;
                    
                    // 随机动画参数
                    const duration = Math.random() * 1 + 0.5;
                    const delay = Math.random() * 2;
                    const height = Math.random() * 20 + 10;
                    
                    // 设置样式
                    raindrop.style.left = `${left}%`;
                    raindrop.style.height = `${height}px`;
                    raindrop.style.animation = `
                        rainAnimation ${duration}s linear ${delay}s infinite
                    `;
                    
                    // 添加到页面
                    overlay.appendChild(raindrop);
                    
                    // 动态创建CSS动画
                    if (!document.getElementById('rain-animation')) {
                        const style = document.createElement('style');
                        style.id = 'rain-animation';
                        style.textContent = `
                            @keyframes rainAnimation {
                                0% {
                                    transform: translateY(-100px);
                                    opacity: 1;
                                }
                                100% {
                                    transform: translateY(100vh);
                                    opacity: 0;
                                }
                            }
                        `;
                        document.head.appendChild(style);
                    }
                }
            }
            
            // 添加获胜连线特效
            addWinningLineEffect() {
                // 让获胜连线闪烁
                if (this.winningLine) {
                    let blinkCount = 0;
                    const maxBlinks = 10;
                    
                    const blinkInterval = setInterval(() => {
                        if (blinkCount >= maxBlinks * 2) {
                            clearInterval(blinkInterval);
                            this.winningLine.material.opacity = 1;
                            return;
                        }
                        
                        this.winningLine.material.opacity = blinkCount % 2 === 0 ? 0.3 : 1;
                        blinkCount++;
                    }, 300);
                }
            }
            
            // 隐藏结算画面
            hideGameResult() {
                const overlay = document.getElementById('game-overlay');
                overlay.style.display = 'none';
                
                // 清除所有效果元素
                const fireworks = document.querySelectorAll('.firework');
                fireworks.forEach(firework => firework.remove());
                
                const raindrops = document.querySelectorAll('.raindrop');
                raindrops.forEach(raindrop => raindrop.remove());
                
                // 停止连线闪烁
                if (this.winningLine) {
                    this.winningLine.material.opacity = 1;
                }
            }
            
            // AI走棋
            aiMove() {
                if (!this.gameActive || this.gameMode !== 'pve') return;
                
                // 更新状态显示
                document.getElementById('status').textContent = 'AI思考中...';
                
                // 使用setTimeout给UI一个更新的机会
                setTimeout(() => {
                    // 获取AI的最佳移动
                    const move = this.ai.getBestMove(this.board, this.boardSize);
                    
                    if (move) {
                        // 执行AI的移动
                        this.placeStone(move.x, move.y, move.z);
                        
                        // 更新预览位置
                        this.previewPosition = {x: move.x, y: move.y, z: move.z};
                        this.updatePreviewPosition();
                    }
                }, 100);
            }
            
            // 检查是否获胜
            checkWin(x, y, z) {
                const player = this.board[x][y][z];
                if (player === 0) return false;
                
                // 定义所有可能的方向向量（三维空间中的26个方向）
                const directions = [
                    // 轴向方向
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0}, // X轴
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0}, // Y轴
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1}, // Z轴
                    
                    // 平面对角线
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    
                    // 空间对角线
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 检查每个方向
                for (const dir of directions) {
                    let count = 1; // 当前位置已经有一个棋子
                    
                    // 正向检查
                    let nx = x + dir.dx;
                    let ny = y + dir.dy;
                    let nz = z + dir.dz;
                    
                    while (nx >= 0 && nx < this.boardSize && 
                           ny >= 0 && ny < this.boardSize && 
                           nz >= 0 && nz < this.boardSize &&
                           this.board[nx][ny][nz] === player) {
                        count++;
                        nx += dir.dx;
                        ny += dir.dy;
                        nz += dir.dz;
                    }
                    
                    // 反向检查
                    nx = x - dir.dx;
                    ny = y - dir.dy;
                    nz = z - dir.dz;
                    
                    while (nx >= 0 && nx < this.boardSize && 
                           ny >= 0 && ny < this.boardSize && 
                           nz >= 0 && nz < this.boardSize &&
                           this.board[nx][ny][nz] === player) {
                        count++;
                        nx -= dir.dx;
                        ny -= dir.dy;
                        nz -= dir.dz;
                    }
                    
                    // 如果连成五个或以上，则获胜
                    if (count >= 5) {
                        // 找到所有获胜的棋子坐标
                        const winningStonesCoords = this.getWinningStonesCoords(x, y, z, dir, count);
                        this.highlightWinningLine(x, y, z, dir, count);
                        
                        // 存储获胜棋子坐标
                        this.winningStonesCoords = winningStonesCoords;
                        
                        // 更新获胜棋子材质
                        this.updateWinningStonesMaterial();
                        
                        return true;
                    }
                }
                
                return false;
            }
            
            // 获取获胜棋子坐标
            getWinningStonesCoords(x, y, z, dir, count) {
                const coords = [];
                
                // 反向找到连线的起点
                let startX = x;
                let startY = y;
                let startZ = z;
                
                while (startX - dir.dx >= 0 && startX - dir.dx < this.boardSize &&
                       startY - dir.dy >= 0 && startY - dir.dy < this.boardSize &&
                       startZ - dir.dz >= 0 && startZ - dir.dz < this.boardSize &&
                       this.board[startX - dir.dx][startY - dir.dy][startZ - dir.dz] === this.board[x][y][z]) {
                    startX -= dir.dx;
                    startY -= dir.dy;
                    startZ -= dir.dz;
                }
                
                // 收集所有获胜棋子的坐标
                for (let i = 0; i < count; i++) {
                    const stoneX = startX + i * dir.dx;
                    const stoneY = startY + i * dir.dy;
                    const stoneZ = startZ + i * dir.dz;
                    coords.push({x: stoneX, y: stoneY, z: stoneZ});
                }
                
                return coords;
            }
            
            // 更新获胜棋子的材质
            updateWinningStonesMaterial() {
                // 清除之前的获胜棋子
                this.winningStones = [];
                
                if (!this.winningStonesCoords) return;
                
                // 为每个获胜棋子创建特殊材质
                this.winningStonesCoords.forEach(coord => {
                    // 在stoneGroup中查找对应的棋子
                    this.stoneGroup.children.forEach(stone => {
                        if (stone.userData.x === coord.x && 
                            stone.userData.y === coord.y && 
                            stone.userData.z === coord.z) {
                            
                            // 创建发光材质
                            const glowingMaterial = new THREE.MeshStandardMaterial({ 
                                color: stone.material.color,
                                emissive: stone.material.color,
                                emissiveIntensity: 0.5,
                                roughness: 0.3,
                                metalness: 0.7
                            });
                            
                            // 保存原始材质以便恢复
                            stone.userData.originalMaterial = stone.material;
                            stone.material = glowingMaterial;
                            
                            // 存储到获胜棋子列表
                            this.winningStones.push(stone);
                        }
                    });
                });
            }
            
            // 更新获胜棋子动画
            updateWinningAnimation() {
                if (!this.winningAnimationActive || this.winningStones.length === 0) return;
                
                // 更新动画时间
                this.winningStoneAnimationTime += 0.05;
                
                // 彩虹色循环
                const hue = (this.winningStoneAnimationTime * 50) % 360;
                
                // 为每个获胜棋子更新材质
                this.winningStones.forEach(stone => {
                    if (stone.material) {
                        // 计算闪烁效果
                        const pulse = Math.sin(this.winningStoneAnimationTime * 3) * 0.3 + 0.7;
                        
                        // 设置彩虹色
                        const color = new THREE.Color(`hsl(${hue}, 100%, 50%)`);
                        stone.material.color = color;
                        stone.material.emissive = color;
                        stone.material.emissiveIntensity = pulse;
                        
                        // 轻微缩放效果
                        const scale = 1 + Math.sin(this.winningStoneAnimationTime * 5) * 0.1;
                        stone.scale.set(scale, scale, scale);
                    }
                });
                
                // 更新点光源位置跟随获胜棋子
                if (this.winningStones.length > 0) {
                    const firstStone = this.winningStones[0];
                    this.pointLight.position.copy(firstStone.position);
                    this.pointLight.position.y += 2;
                    
                    // 点光源也闪烁
                    this.pointLight.intensity = Math.sin(this.winningStoneAnimationTime * 3) * 0.5 + 1;
                }
            }
            
            // 高亮显示获胜连线
            highlightWinningLine(x, y, z, dir, count) {
                const offset = (this.boardSize - 1) / 2;
                
                // 计算连线的起点和终点
                let startX = x;
                let startY = y;
                let startZ = z;
                
                // 反向找到连线的起点
                while (startX - dir.dx >= 0 && startX - dir.dx < this.boardSize &&
                       startY - dir.dy >= 0 && startY - dir.dy < this.boardSize &&
                       startZ - dir.dz >= 0 && startZ - dir.dz < this.boardSize &&
                       this.board[startX - dir.dx][startY - dir.dy][startZ - dir.dz] === this.board[x][y][z]) {
                    startX -= dir.dx;
                    startY -= dir.dy;
                    startZ -= dir.dz;
                }
                
                // 计算连线的终点
                let endX = startX + (count - 1) * dir.dx;
                let endY = startY + (count - 1) * dir.dy;
                let endZ = startZ + (count - 1) * dir.dz;
                
                // 创建连线
                const points = [];
                points.push(new THREE.Vector3(
                    startX - offset,
                    startY,
                    startZ - offset
                ));
                points.push(new THREE.Vector3(
                    endX - offset,
                    endY,
                    endZ - offset
                ));
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xffd700, 
                    linewidth: 5,
                    transparent: true,
                    opacity: 1
                });
                
                this.winningLine = new THREE.Line(geometry, material);
                this.scene.add(this.winningLine);
            }
            
            // 渲染棋子
            renderStone(x, y, z) {
                const color = this.board[x][y][z];
                if (color === 0) return;
                
                // 移除可能已存在的棋子模型
                this.removeStoneModel(x, y, z);
                
                const offset = (this.boardSize - 1) / 2;
                
                // 创建棋子
                const geometry = new THREE.SphereGeometry(0.4, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: color === 1 ? 0x000000 : 0xffffff,
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                const stone = new THREE.Mesh(geometry, material);
                stone.position.set(x - offset, y, z - offset);
                stone.userData = {x, y, z};
                this.stoneGroup.add(stone);
            }
            
            // 移除棋子模型
            removeStoneModel(x, y, z) {
                for (let i = this.stoneGroup.children.length - 1; i >= 0; i--) {
                    const stone = this.stoneGroup.children[i];
                    if (stone.userData.x === x && stone.userData.y === y && stone.userData.z === z) {
                        this.stoneGroup.remove(stone);
                        break;
                    }
                }
            }
            
            // 坐标输入落子
            placeByCoordinates() {
                const x = parseInt(document.getElementById('x-input').value);
                const y = parseInt(document.getElementById('y-input').value);
                const z = parseInt(document.getElementById('z-input').value);
                
                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    alert('请输入有效的坐标值！');
                    return;
                }
                
                if (this.placeStone(x, y, z)) {
                    // 更新预览位置
                    this.previewPosition = {x, y, z};
                    this.updatePreviewPosition();
                }
            }
            
            // 切换游戏模式
            setGameMode(mode) {
                this.gameMode = mode;
                this.updateUI();
                
                // 如果切换到PvE模式且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 设置AI难度
            setAIDifficulty(difficulty) {
                this.aiDifficulty = difficulty;
                this.ai = new GomokuAI(this.aiDifficulty, this.playerColor);
            }
            
            // 设置玩家颜色
            setPlayerColor(color) {
                this.playerColor = color === 'black' ? 1 : 2;
                this.ai = new GomokuAI(this.aiDifficulty, this.playerColor);
                
                // 如果游戏正在进行中且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 更新预览
            updatePreview() {
                this.updatePreviewPosition();
            }
            
            // 微调预览位置
            adjustPreview(dx, dy, dz) {
                this.previewPosition.x = Math.max(0, Math.min(this.boardSize - 1, this.previewPosition.x + dx));
                this.previewPosition.y = Math.max(0, Math.min(this.boardSize - 1, this.previewPosition.y + dy));
                this.previewPosition.z = Math.max(0, Math.min(this.boardSize - 1, this.previewPosition.z + dz));
                
                this.updatePreview();
            }
            
            // 设置棋盘大小
            setBoardSize(size) {
                if (size < 5 || size > 21) {
                    alert('棋盘大小必须在5到21之间！');
                    return;
                }
                
                this.boardSize = size;
                this.currentLayer = Math.floor(this.boardSize / 2);
                
                // 重置预览位置到中心
                this.previewPosition = {
                    x: Math.floor(this.boardSize / 2),
                    y: Math.floor(this.boardSize / 2),
                    z: Math.floor(this.boardSize / 2)
                };
                
                this.createBoard();
                this.updateUI();
                this.updatePreview();
            }
            
            // 切换拖动模式
            toggleDragMode() {
                this.dragEnabled = !this.dragEnabled;
                this.controls.enablePan = this.dragEnabled;
                document.getElementById('toggle-drag').textContent = 
                    `拖动模式: ${this.dragEnabled ? '开启' : '关闭'}`;
            }
            
            // 更新UI
            updateUI() {
                // 更新当前玩家显示
                const playerIndicator = document.querySelector('#current-player .player-indicator');
                const playerText = document.querySelector('#current-player span');
                
                if (this.currentPlayer === 1) {
                    playerIndicator.className = 'player-indicator black';
                    playerText.textContent = '当前玩家: 黑方';
                } else {
                    playerIndicator.className = 'player-indicator white';
                    playerText.textContent = '当前玩家: 白方';
                }
                
                // 更新游戏状态
                const statusElement = document.getElementById('status');
                if (this.gameActive) {
                    if (this.gameMode === 'pve') {
                        if ((this.playerColor === 1 && this.currentPlayer === 1) || 
                            (this.playerColor === 2 && this.currentPlayer === 2)) {
                            statusElement.textContent = '玩家回合';
                        } else {
                            statusElement.textContent = 'AI回合';
                        }
                    } else {
                        statusElement.textContent = '游戏进行中';
                    }
                    statusElement.style.color = '#2ecc71';
                } else {
                    statusElement.style.color = '#e74c3c';
                }
                
                // 更新输入框范围
                const maxCoord = this.boardSize - 1;
                document.getElementById('x-input').max = maxCoord;
                document.getElementById('y-input').max = maxCoord;
                document.getElementById('z-input').max = maxCoord;
            }
            
            // 新游戏
            newGame() {
                // 隐藏结算画面
                this.hideGameResult();
                
                // 恢复获胜棋子的原始材质（如果有的话）
                this.winningStones.forEach(stone => {
                    if (stone.userData.originalMaterial) {
                        stone.material = stone.userData.originalMaterial;
                        stone.scale.set(1, 1, 1);
                    }
                });
                
                this.createBoard();
                this.currentPlayer = 1;
                this.gameActive = true;
                
                this.updateUI();
                this.updatePreview();
            }
            
            // 跳过回合
            passTurn() {
                if (!this.gameActive) return;
                
                this.currentPlayer = 3 - this.currentPlayer;
                this.updateUI();
                this.updatePreview();
                
                // 如果是PvE模式且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 认输
            resign() {
                if (!this.gameActive) return;
                
                this.gameActive = false;
                const winner = this.currentPlayer === 1 ? '白方' : '黑方';
                document.getElementById('status').textContent = `${winner}获胜！`;
                this.updateUI();
                
                // 显示结算画面（认输情况）
                this.showGameResult(this.currentPlayer === 1 ? 2 : 1);
            }
            
            // 重置视角
            resetView() {
                this.camera.position.set(20, 15, 20);
                this.controls.reset();
            }
            
            // 设置事件监听器
            setupEventListeners() {
                // 游戏模式选择
                document.getElementById('game-mode').addEventListener('change', (e) => {
                    this.setGameMode(e.target.value);
                });
                
                // AI难度选择
                document.getElementById('ai-difficulty').addEventListener('change', (e) => {
                    this.setAIDifficulty(e.target.value);
                });
                
                // 玩家颜色选择
                document.getElementById('player-color').addEventListener('change', (e) => {
                    this.setPlayerColor(e.target.value);
                });
                
                // 落子按钮
                document.getElementById('place-btn').addEventListener('click', () => this.placeByCoordinates());
                
                // 层控制
                const layerSlider = document.getElementById('layer-slider');
                layerSlider.addEventListener('input', (e) => {
                    this.currentLayer = parseInt(e.target.value);
                    this.updateLayerIndicator();
                    this.previewPosition.y = this.currentLayer;
                    this.updatePreview();
                });
                
                document.getElementById('prev-layer').addEventListener('click', () => {
                    if (this.currentLayer > 0) {
                        this.currentLayer--;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                
                document.getElementById('next-layer').addEventListener('click', () => {
                    if (this.currentLayer < this.boardSize - 1) {
                        this.currentLayer++;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                
                // 棋盘大小设置
                document.getElementById('set-board-size').addEventListener('click', () => {
                    const size = parseInt(document.getElementById('board-size-input').value);
                    this.setBoardSize(size);
                });
                
                // 微调按钮
                document.getElementById('key-up').addEventListener('click', () => this.adjustPreview(0, 1, 0));
                document.getElementById('key-down').addEventListener('click', () => this.adjustPreview(0, -1, 0));
                document.getElementById('key-left').addEventListener('click', () => this.adjustPreview(-1, 0, 0));
                document.getElementById('key-right').addEventListener('click', () => this.adjustPreview(1, 0, 0));
                document.getElementById('key-front').addEventListener('click', () => this.adjustPreview(0, 0, 1));
                document.getElementById('key-back').addEventListener('click', () => this.adjustPreview(0, 0, -1));
                document.getElementById('key-layer-up').addEventListener('click', () => {
                    if (this.currentLayer < this.boardSize - 1) {
                        this.currentLayer++;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                document.getElementById('key-layer-down').addEventListener('click', () => {
                    if (this.currentLayer > 0) {
                        this.currentLayer--;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                document.getElementById('key-center').addEventListener('click', () => {
                    this.placeByCoordinates();
                });
                
                // 键盘控制 - 修改部分
                document.addEventListener('keydown', (e) => {
                    if (!this.gameActive) return;
                    
                    // 黑方控制 (玩家1)
                    if (this.currentPlayer === 1) {
                        switch(e.key.toLowerCase()) {
                            case 'w':
                                e.preventDefault();
                                this.adjustPreview(1, 0, 0); // X+
                                break;
                            case 's':
                                e.preventDefault();
                                this.adjustPreview(-1, 0, 0); // X-
                                break;
                            case 'a':
                                e.preventDefault();
                                this.adjustPreview(0, 0, 1); // Z+
                                break;
                            case 'd':
                                e.preventDefault();
                                this.adjustPreview(0, 0, -1); // Z-
                                break;
                            case 'q':
                                e.preventDefault();
                                this.adjustPreview(0, 1, 0); // Y+
                                break;
                            case 'e':
                                e.preventDefault();
                                this.adjustPreview(0, -1, 0); // Y-
                                break;
                            case 'enter':
                                e.preventDefault();
                                this.placeByCoordinates();
                                break;
                        }
                    }
                    // 白方控制 (玩家2)
                    else if (this.currentPlayer === 2) {
                        switch(e.key) {
                            case 'ArrowUp':
                                e.preventDefault();
                                this.adjustPreview(1, 0, 0); // X+
                                break;
                            case 'ArrowDown':
                                e.preventDefault();
                                this.adjustPreview(-1, 0, 0); // X-
                                break;
                            case 'ArrowLeft':
                                e.preventDefault();
                                this.adjustPreview(0, 0, 1); // Z+
                                break;
                            case 'ArrowRight':
                                e.preventDefault();
                                this.adjustPreview(0, 0, -1); // Z-
                                break;
                            case 'PageUp':
                                e.preventDefault();
                                this.adjustPreview(0, 1, 0); // Y+
                                break;
                            case 'PageDown':
                                e.preventDefault();
                                this.adjustPreview(0, -1, 0); // Y-
                                break;
                            case 'Enter':
                                e.preventDefault();
                                this.placeByCoordinates();
                                break;
                        }
                    }
                });
                
                // UI控制
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
                document.getElementById('pass-turn').addEventListener('click', () => this.passTurn());
                document.getElementById('resign').addEventListener('click', () => this.resign());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                document.getElementById('toggle-drag').addEventListener('click', () => this.toggleDragMode());
                
                // 结算画面按钮事件
                document.getElementById('continue-btn').addEventListener('click', () => {
                    this.hideGameResult();
                });
                
                document.getElementById('new-game-btn').addEventListener('click', () => {
                    this.newGame();
                });
                
                // 输入框回车事件
                document.getElementById('x-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeByCoordinates();
                });
                document.getElementById('y-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeByCoordinates();
                });
                document.getElementById('z-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeByCoordinates();
                });
                document.getElementById('board-size-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const size = parseInt(document.getElementById('board-size-input').value);
                        this.setBoardSize(size);
                    }
                });
            }
            
            // 窗口大小调整
            onWindowResize() {
                this.camera.aspect = (window.innerWidth * 0.75) / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
            }
            
            // 动画循环
            animate() {
                requestAnimationFrame(() => this.animate());
                
                // 更新控制器
                this.controls.update();
                
                // 更新获胜棋子动画
                if (this.winningAnimationActive) {
                    this.updateWinningAnimation();
                }
                
                // 渲染场景
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // 初始化游戏
        window.addEventListener('DOMContentLoaded', () => {
            const game = new ThreeDGomoku();
        });
    </script>
</body>
</html>