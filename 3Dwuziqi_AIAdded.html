<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>三维五子棋</title>
    <style>
        /* 所有样式保持不变 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            color: white;
            overflow: hidden;
            height: 100vh;
        }
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        #header {
            text-align: center;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }
        #header h1 {
            margin-bottom: 10px;
            font-size: 2.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        #header p {
            font-size: 1.2rem;
            max-width: 800px;
            margin: 0 auto;
            line-height: 1.5;
        }
        #content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #game-container {
            flex: 3;
            position: relative;
        }
        #ui-panel {
            flex: 1;
            max-width: 350px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            overflow-y: auto;
            border-left: 2px solid rgba(255, 255, 255, 0.2);
        }
        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        #game-info {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
        }
        h2 {
            margin-bottom: 15px;
            font-size: 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.3);
            padding-bottom: 5px;
        }
        .btn {
            padding: 10px 15px;
            background: #4a90e2;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s;
            margin: 5px;
        }
        .btn:hover {
            background: #357ae8;
            transform: translateY(-2px);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-danger {
            background: #e74c3c;
        }
        .btn-danger:hover {
            background: #c0392b;
        }
        .btn-success {
            background: #2ecc71;
        }
        .btn-success:hover {
            background: #27ae60;
        }
        #status {
            font-size: 1.2rem;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        #coordinates {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #ccc;
        }
        .slider-container {
            margin: 10px 0;
        }
        .slider-container label {
            display: block;
            margin-bottom: 5px;
        }
        input[type="range"] {
            width: 100%;
        }
        .rules {
            margin-top: 20px;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        .rules h3 {
            margin: 10px 0 5px 0;
            color: #4a90e2;
        }
        .rules ul {
            padding-left: 20px;
        }
        .rules li {
            margin-bottom: 5px;
        }
        #current-player {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        .player-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
        }
        .black {
            background: #000;
            border: 1px solid #fff;
        }
        .white {
            background: #fff;
            border: 1px solid #000;
        }
        .coordinate-input {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }
        .coordinate-input input {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
        }
        .coordinate-input input:focus {
            outline: none;
            border-color: #4a90e2;
        }
        .placement-mode {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .mode-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mode-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }
        .layer-info {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }
        .layer-controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .layer-btn {
            flex: 1;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .layer-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        .board-size-control {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        .board-size-control input {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            text-align: center;
        }
        .key-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
            margin: 10px 0;
        }
        .key-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #555;
            color: white;
            border-radius: 5px;
            text-align: center;
            font-size: 0.8rem;
        }
        .key-btn.active {
            background: #4a90e2;
            border-color: #4a90e2;
        }
        #instructions {
            margin-top: 20px;
            font-size: 0.9rem;
            color: #ccc;
        }
        .winning-line {
            position: absolute;
            background: rgba(255, 215, 0, 0.7);
            z-index: 100;
        }
        .ai-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .ai-options {
            display: flex;
            gap: 10px;
        }
        .ai-options select {
            flex: 1;
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #555;
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        @media (max-width: 768px) {
            #content {
                flex-direction: column;
            }
            #ui-panel {
                max-width: 100%;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <h1>三维五子棋</h1>
            <p>在三维空间中连成五个或以上相同颜色的棋子即可获胜</p>
        </div>
        <div id="content">
            <div id="game-container">
                <div id="canvas-container"></div>
            </div>
            <div id="ui-panel">
                <div id="game-info">
                    <h2>游戏状态</h2>
                    <div id="status">黑方先行</div>
                    <div id="current-player">
                        <div class="player-indicator black"></div>
                        <span>当前玩家: 黑方</span>
                    </div>
                    <div class="layer-info">
                        <span>当前层: <span id="layer-value">9</span></span>
                        <span>落子模式: <span id="mode-value">当前层</span></span>
                    </div>
                    <div id="coordinates">预览位置: (9, 9, 9)</div>
                </div>
                <div id="controls">
                    <div class="control-group">
                        <h2>游戏模式</h2>
                        <div class="ai-controls">
                            <div class="ai-options">
                                <select id="game-mode">
                                    <option value="pvp">玩家 vs 玩家</option>
                                    <option value="pve">玩家 vs AI</option>
                                </select>
                                <select id="ai-difficulty">
                                    <option value="easy">简单</option>
                                    <option value="medium" selected>中等</option>
                                    <option value="hard">困难</option>
                                </select>
                            </div>
                            <div class="ai-options">
                                <select id="player-color">
                                    <option value="black" selected>玩家执黑</option>
                                    <option value="white">玩家执白</option>
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>棋盘设置</h2>
                        <div class="board-size-control">
                            <input type="number" id="board-size-input" min="5" max="21" value="15">
                            <button id="set-board-size" class="btn">设置棋盘大小</button>
                        </div>
                        <div style="font-size: 0.9rem; color: #ccc; margin-top: 5px;">
                            棋盘大小: 5x5x5 到 21x21x21
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>落子方式</h2>
                        <div class="placement-mode">
                            <button id="mode-coord" class="mode-btn">坐标输入</button>
                            <button id="mode-layer" class="mode-btn active">当前层</button>
                        </div>
                        
                        <div id="coord-input" class="coordinate-input" style="display: none;">
                            <input type="number" id="x-input" min="0" max="14" placeholder="X" value="7">
                            <input type="number" id="y-input" min="0" max="14" placeholder="Y" value="7">
                            <input type="number" id="z-input" min="0" max="14" placeholder="Z" value="7">
                            <button id="place-btn" class="btn">落子</button>
                        </div>
                        
                        <div id="layer-input">
                            <div class="coordinate-input">
                                <input type="number" id="layer-x-input" min="0" max="14" placeholder="X" value="7">
                                <input type="number" id="layer-z-input" min="0" max="14" placeholder="Z" value="7">
                                <button id="layer-place-btn" class="btn">在当前层落子</button>
                            </div>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>位置微调</h2>
                        <div class="key-controls">
                            <div class="key-btn" id="key-up">↑ Y+</div>
                            <div class="key-btn" id="key-down">↓ Y-</div>
                            <div class="key-btn" id="key-layer-up">层+</div>
                            <div class="key-btn" id="key-left">← X-</div>
                            <div class="key-btn" id="key-center">确认</div>
                            <div class="key-btn" id="key-right">→ X+</div>
                            <div class="key-btn" id="key-front">前 Z+</div>
                            <div class="key-btn" id="key-back">后 Z-</div>
                            <div class="key-btn" id="key-layer-down">层-</div>
                        </div>
                        <div style="font-size: 0.9rem; color: #ccc; margin-top: 5px;">
                            点击按钮或使用键盘方向键微调位置
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>层控制</h2>
                        <div class="slider-container">
                            <label for="layer-slider">层数: <span id="layer-display">7</span></label>
                            <input type="range" id="layer-slider" min="0" max="14" value="7">
                        </div>
                        <div class="layer-controls">
                            <button id="prev-layer" class="layer-btn">上一层</button>
                            <button id="next-layer" class="layer-btn">下一层</button>
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <h2>游戏控制</h2>
                        <button id="new-game" class="btn btn-success">新游戏</button>
                        <button id="pass-turn" class="btn">跳过回合</button>
                        <button id="resign" class="btn btn-danger">认输</button>
                        <button id="reset-view" class="btn">重置视角</button>
                        <button id="toggle-drag" class="btn">拖动模式: 关闭</button>
                    </div>
                    
                    <div class="rules">
                        <h2>三维五子棋规则</h2>
                        <h3>基本规则</h3>
                        <ul>
                            <li>棋盘为NxNxN的三维网格</li>
                            <li>黑白双方交替落子</li>
                            <li>先在任意直线方向连成五个或以上相同颜色棋子的一方获胜</li>
                        </ul>
                        <h3>获胜条件</h3>
                        <ul>
                            <li>在任意直线方向（包括三维对角线）连成五个或以上相同颜色的棋子</li>
                            <li>方向包括：水平、垂直、对角线（平面和空间对角线）</li>
                        </ul>
                        <h3>特殊规则</h3>
                        <ul>
                            <li>无禁手规则</li>
                            <li>超过五个棋子连线同样获胜</li>
                        </ul>
                    </div>
                    <div id="instructions">
                        <p>操作说明：</p>
                        <p>• 鼠标拖拽：旋转视角</p>
                        <p>• 鼠标滚轮：缩放</p>
                        <p>• 中键拖拽：平移棋盘</p>
                        <p>• 使用坐标输入或当前层模式落子</p>
                        <p>• 方向键微调落子位置</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script>
        // AI类
        class GomokuAI {
            constructor(difficulty = 'medium', playerColor = 1) {
                this.difficulty = difficulty;
                this.playerColor = playerColor;
                this.aiColor = 3 - playerColor;
                
                // 根据难度设置搜索深度
                switch(difficulty) {
                    case 'easy':
                        this.searchDepth = 1;
                        break;
                    case 'medium':
                        this.searchDepth = 2;
                        break;
                    case 'hard':
                        this.searchDepth = 3;
                        break;
                }
            }
            
            // 获取最佳移动
            getBestMove(board, boardSize) {
                let bestScore = -Infinity;
                let bestMove = null;
                
                // 获取所有可能的移动
                const possibleMoves = this.getPossibleMoves(board, boardSize);
                
                // 如果没有可能的移动，返回null
                if (possibleMoves.length === 0) {
                    return null;
                }
                
                // 根据难度限制搜索的移动数量
                let movesToSearch = possibleMoves;
                if (this.difficulty !== 'hard' && possibleMoves.length > 20) {
                    // 按启发式分数排序并取前几个
                    movesToSearch = possibleMoves
                        .sort((a, b) => this.evaluateMove(board, boardSize, b.x, b.y, b.z) - 
                                        this.evaluateMove(board, boardSize, a.x, a.y, a.z))
                        .slice(0, 20);
                }
                
                // 对每个可能的移动进行搜索
                for (const move of movesToSearch) {
                    // 模拟移动
                    board[move.x][move.y][move.z] = this.aiColor;
                    
                    // 计算分数
                    let score;
                    if (this.searchDepth > 1) {
                        score = this.minimax(board, boardSize, this.searchDepth - 1, false, -Infinity, Infinity);
                    } else {
                        score = this.evaluateBoard(board, boardSize);
                    }
                    
                    // 撤销移动
                    board[move.x][move.y][move.z] = 0;
                    
                    // 更新最佳移动
                    if (score > bestScore) {
                        bestScore = score;
                        bestMove = move;
                    }
                }
                
                return bestMove;
            }
            
            // 获取所有可能的移动（只考虑有棋子相邻的位置以提高效率）
            getPossibleMoves(board, boardSize) {
                const moves = [];
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 首先检查中心区域
                const center = Math.floor(boardSize / 2);
                const searchRadius = Math.min(3, Math.floor(boardSize / 2));
                
                for (let x = Math.max(0, center - searchRadius); x <= Math.min(boardSize - 1, center + searchRadius); x++) {
                    for (let y = Math.max(0, center - searchRadius); y <= Math.min(boardSize - 1, center + searchRadius); y++) {
                        for (let z = Math.max(0, center - searchRadius); z <= Math.min(boardSize - 1, center + searchRadius); z++) {
                            if (board[x][y][z] === 0) {
                                // 检查是否有棋子相邻
                                for (const dir of directions) {
                                    const nx = x + dir.dx;
                                    const ny = y + dir.dy;
                                    const nz = z + dir.dz;
                                    
                                    if (nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize && nz >= 0 && nz < boardSize) {
                                        if (board[nx][ny][nz] !== 0) {
                                            moves.push({x, y, z});
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // 如果没有找到任何移动，返回棋盘中心
                if (moves.length === 0) {
                    moves.push({x: center, y: center, z: center});
                }
                
                return moves;
            }
            
            // Minimax算法
            minimax(board, boardSize, depth, isMaximizing, alpha, beta) {
                // 检查游戏是否结束
                const gameResult = this.checkGameResult(board, boardSize);
                if (gameResult !== 0 || depth === 0) {
                    return this.evaluateBoard(board, boardSize);
                }
                
                if (isMaximizing) {
                    let maxScore = -Infinity;
                    const possibleMoves = this.getPossibleMoves(board, boardSize);
                    
                    for (const move of possibleMoves) {
                        board[move.x][move.y][move.z] = this.aiColor;
                        const score = this.minimax(board, boardSize, depth - 1, false, alpha, beta);
                        board[move.x][move.y][move.z] = 0;
                        
                        maxScore = Math.max(maxScore, score);
                        alpha = Math.max(alpha, score);
                        
                        if (beta <= alpha) {
                            break; // Beta剪枝
                        }
                    }
                    
                    return maxScore;
                } else {
                    let minScore = Infinity;
                    const possibleMoves = this.getPossibleMoves(board, boardSize);
                    
                    for (const move of possibleMoves) {
                        board[move.x][move.y][move.z] = this.playerColor;
                        const score = this.minimax(board, boardSize, depth - 1, true, alpha, beta);
                        board[move.x][move.y][move.z] = 0;
                        
                        minScore = Math.min(minScore, score);
                        beta = Math.min(beta, score);
                        
                        if (beta <= alpha) {
                            break; // Alpha剪枝
                        }
                    }
                    
                    return minScore;
                }
            }
            
            // 评估棋盘状态
            evaluateBoard(board, boardSize) {
                let score = 0;
                
                // 检查所有可能的方向
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 遍历所有位置
                for (let x = 0; x < boardSize; x++) {
                    for (let y = 0; y < boardSize; y++) {
                        for (let z = 0; z < boardSize; z++) {
                            if (board[x][y][z] !== 0) {
                                // 对每个方向评估
                                for (const dir of directions) {
                                    const lineScore = this.evaluateLine(board, boardSize, x, y, z, dir.dx, dir.dy, dir.dz);
                                    if (board[x][y][z] === this.aiColor) {
                                        score += lineScore;
                                    } else {
                                        score -= lineScore * 1.2; // 防守比进攻更重要
                                    }
                                }
                            }
                        }
                    }
                }
                
                return score;
            }
            
            // 评估单个移动
            evaluateMove(board, boardSize, x, y, z) {
                if (board[x][y][z] !== 0) return -Infinity;
                
                let score = 0;
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 模拟放置棋子
                board[x][y][z] = this.aiColor;
                
                // 评估这个位置
                for (const dir of directions) {
                    score += this.evaluateLine(board, boardSize, x, y, z, dir.dx, dir.dy, dir.dz);
                }
                
                // 撤销模拟
                board[x][y][z] = 0;
                
                return score;
            }
            
            // 评估一条线上的棋子
            evaluateLine(board, boardSize, x, y, z, dx, dy, dz) {
                const player = board[x][y][z];
                if (player === 0) return 0;
                
                let count = 1; // 当前位置的棋子
                let openEnds = 0;
                
                // 正向检查
                let nx = x + dx;
                let ny = y + dy;
                let nz = z + dz;
                
                while (nx >= 0 && nx < boardSize && 
                       ny >= 0 && ny < boardSize && 
                       nz >= 0 && nz < boardSize &&
                       board[nx][ny][nz] === player) {
                    count++;
                    nx += dx;
                    ny += dy;
                    nz += dz;
                }
                
                // 检查正向是否开放
                if (nx >= 0 && nx < boardSize && 
                    ny >= 0 && ny < boardSize && 
                    nz >= 0 && nz < boardSize &&
                    board[nx][ny][nz] === 0) {
                    openEnds++;
                }
                
                // 反向检查
                nx = x - dx;
                ny = y - dy;
                nz = z - dz;
                
                while (nx >= 0 && nx < boardSize && 
                       ny >= 0 && ny < boardSize && 
                       nz >= 0 && nz < boardSize &&
                       board[nx][ny][nz] === player) {
                    count++;
                    nx -= dx;
                    ny -= dy;
                    nz -= dz;
                }
                
                // 检查反向是否开放
                if (nx >= 0 && nx < boardSize && 
                    ny >= 0 && ny < boardSize && 
                    nz >= 0 && nz < boardSize &&
                    board[nx][ny][nz] === 0) {
                    openEnds++;
                }
                
                // 根据连子数量和开放程度评分
                if (count >= 5) {
                    return 100000; // 获胜
                } else if (count === 4) {
                    if (openEnds === 2) return 10000; // 活四
                    if (openEnds === 1) return 1000;  // 冲四
                } else if (count === 3) {
                    if (openEnds === 2) return 1000;  // 活三
                    if (openEnds === 1) return 100;   // 冲三
                } else if (count === 2) {
                    if (openEnds === 2) return 100;   // 活二
                    if (openEnds === 1) return 10;    // 冲二
                } else if (count === 1) {
                    if (openEnds === 2) return 10;    // 活一
                    if (openEnds === 1) return 1;     // 冲一
                }
                
                return 0;
            }
            
            // 检查游戏结果
            checkGameResult(board, boardSize) {
                // 遍历所有位置检查是否有五连子
                for (let x = 0; x < boardSize; x++) {
                    for (let y = 0; y < boardSize; y++) {
                        for (let z = 0; z < boardSize; z++) {
                            if (board[x][y][z] !== 0) {
                                if (this.checkWinFromPosition(board, boardSize, x, y, z)) {
                                    return board[x][y][z];
                                }
                            }
                        }
                    }
                }
                
                return 0; // 游戏继续
            }
            
            // 从指定位置检查是否获胜
            checkWinFromPosition(board, boardSize, x, y, z) {
                const player = board[x][y][z];
                if (player === 0) return false;
                
                const directions = [
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0},
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0},
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1},
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                for (const dir of directions) {
                    let count = 1;
                    
                    // 正向检查
                    let nx = x + dir.dx;
                    let ny = y + dir.dy;
                    let nz = z + dir.dz;
                    
                    while (nx >= 0 && nx < boardSize && 
                           ny >= 0 && ny < boardSize && 
                           nz >= 0 && nz < boardSize &&
                           board[nx][ny][nz] === player) {
                        count++;
                        nx += dir.dx;
                        ny += dir.dy;
                        nz += dir.dz;
                    }
                    
                    // 反向检查
                    nx = x - dir.dx;
                    ny = y - dir.dy;
                    nz = z - dir.dz;
                    
                    while (nx >= 0 && nx < boardSize && 
                           ny >= 0 && ny < boardSize && 
                           nz >= 0 && nz < boardSize &&
                           board[nx][ny][nz] === player) {
                        count++;
                        nx -= dir.dx;
                        ny -= dir.dy;
                        nz -= dir.dz;
                    }
                    
                    if (count >= 5) {
                        return true;
                    }
                }
                
                return false;
            }
        }

        // 游戏主类
        class ThreeDGomoku {
            constructor() {
                this.boardSize = 15;
                this.currentLayer = Math.floor(this.boardSize / 2);
                this.currentPlayer = 1; // 1: 黑, 2: 白
                this.placementMode = 'layer'; // 'coord' 或 'layer'
                this.dragEnabled = false;
                this.previewPosition = {
                    x: Math.floor(this.boardSize / 2),
                    y: Math.floor(this.boardSize / 2),
                    z: Math.floor(this.boardSize / 2)
                };
                this.winningLine = null;
                this.gameMode = 'pve'; // 'pvp' 或 'pve'
                this.aiDifficulty = 'medium';
                this.playerColor = 1; // 1: 黑, 2: 白
                this.ai = new GomokuAI(this.aiDifficulty, this.playerColor);
                
                this.initThreeJS();
                this.createBoard();
                this.setupEventListeners();
                this.updateUI();
                this.updatePreview();
            }
            
            // 创建空棋盘
            createEmptyBoard() {
                const board = [];
                for (let x = 0; x < this.boardSize; x++) {
                    board[x] = [];
                    for (let y = 0; y < this.boardSize; y++) {
                        board[x][y] = [];
                        for (let z = 0; z < this.boardSize; z++) {
                            board[x][y][z] = 0;
                        }
                    }
                }
                return board;
            }
            
            // 初始化Three.js场景
            initThreeJS() {
                // 场景
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x1a1a2e);
                
                // 相机
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(20, 15, 20);
                
                // 渲染器
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
                this.renderer.shadowMap.enabled = true;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);
                
                // 控制器
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                
                // 光源
                const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 15);
                directionalLight.castShadow = true;
                this.scene.add(directionalLight);
                
                // 辅助网格和坐标轴
                const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
                this.scene.add(gridHelper);
                
                const axesHelper = new THREE.AxesHelper(5);
                this.scene.add(axesHelper);
                
                // 渲染循环
                this.animate();
                
                // 窗口大小调整
                window.addEventListener('resize', () => this.onWindowResize());
            }
            
            // 创建棋盘
            createBoard() {
                // 清除现有棋盘
                if (this.boardGroup) {
                    this.scene.remove(this.boardGroup);
                }
                if (this.stoneGroup) {
                    this.scene.remove(this.stoneGroup);
                }
                if (this.layerIndicator) {
                    this.scene.remove(this.layerIndicator);
                }
                if (this.previewStone) {
                    this.scene.remove(this.previewStone);
                }
                if (this.winningLine) {
                    this.scene.remove(this.winningLine);
                    this.winningLine = null;
                }
                
                this.boardGroup = new THREE.Group();
                this.stoneGroup = new THREE.Group();
                this.scene.add(this.boardGroup);
                this.scene.add(this.stoneGroup);
                
                // 创建棋盘线
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0xaaaaaa });
                const offset = (this.boardSize - 1) / 2;
                
                // X方向线
                for (let x = 0; x < this.boardSize; x++) {
                    for (let z = 0; z < this.boardSize; z++) {
                        const points = [];
                        points.push(new THREE.Vector3(x - offset, 0, z - offset));
                        points.push(new THREE.Vector3(x - offset, this.boardSize - 1, z - offset));
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, lineMaterial);
                        this.boardGroup.add(line);
                    }
                }
                
                // Y方向线
                for (let y = 0; y < this.boardSize; y++) {
                    for (let z = 0; z < this.boardSize; z++) {
                        const points = [];
                        points.push(new THREE.Vector3(-offset, y, z - offset));
                        points.push(new THREE.Vector3(offset, y, z - offset));
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, lineMaterial);
                        this.boardGroup.add(line);
                    }
                }
                
                // Z方向线
                for (let x = 0; x < this.boardSize; x++) {
                    for (let y = 0; y < this.boardSize; y++) {
                        const points = [];
                        points.push(new THREE.Vector3(x - offset, y, -offset));
                        points.push(new THREE.Vector3(x - offset, y, offset));
                        
                        const geometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(geometry, lineMaterial);
                        this.boardGroup.add(line);
                    }
                }
                
                // 创建交叉点标记
                const dotGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const dotMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
                
                for (let x = 0; x < this.boardSize; x++) {
                    for (let y = 0; y < this.boardSize; y++) {
                        for (let z = 0; z < this.boardSize; z++) {
                            // 只在特定位置放置标记点，避免过于密集
                            if ((x % 5 === 0 && y % 5 === 0 && z % 5 === 0) || 
                                (x === offset && y === offset && z === offset)) {
                                const dot = new THREE.Mesh(dotGeometry, dotMaterial);
                                dot.position.set(x - offset, y, z - offset);
                                this.boardGroup.add(dot);
                            }
                        }
                    }
                }
                
                // 创建当前层指示器
                this.layerIndicator = new THREE.Group();
                this.updateLayerIndicator();
                this.scene.add(this.layerIndicator);
                
                // 创建预览棋子
                const previewGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const previewMaterial = new THREE.MeshStandardMaterial({ 
                    color: this.currentPlayer === 1 ? 0x000000 : 0xffffff,
                    roughness: 0.7,
                    metalness: 0.1,
                    transparent: true,
                    opacity: 0.6
                });
                
                this.previewStone = new THREE.Mesh(previewGeometry, previewMaterial);
                this.updatePreviewPosition();
                this.scene.add(this.previewStone);
                
                // 初始化棋盘状态
                this.board = this.createEmptyBoard();
                this.gameActive = true;
                
                // 如果AI执黑且是PvE模式，让AI先走
                if (this.gameMode === 'pve' && this.playerColor === 2 && this.currentPlayer === 1) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 更新当前层指示器
            updateLayerIndicator() {
                // 清除现有指示器
                while(this.layerIndicator.children.length > 0) { 
                    this.layerIndicator.remove(this.layerIndicator.children[0]); 
                }
                
                const offset = (this.boardSize - 1) / 2;
                
                // 创建当前层的平面
                const planeGeometry = new THREE.PlaneGeometry(this.boardSize, this.boardSize);
                const planeMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.1,
                    side: THREE.DoubleSide
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = Math.PI / 2;
                plane.position.y = this.currentLayer;
                this.layerIndicator.add(plane);
                
                // 更新UI
                document.getElementById('layer-value').textContent = this.currentLayer;
                document.getElementById('layer-display').textContent = this.currentLayer;
                
                // 更新滑块
                document.getElementById('layer-slider').max = this.boardSize - 1;
                document.getElementById('layer-slider').value = this.currentLayer;
            }
            
            // 更新预览位置
            updatePreviewPosition() {
                const offset = (this.boardSize - 1) / 2;
                this.previewStone.position.set(
                    this.previewPosition.x - offset,
                    this.previewPosition.y,
                    this.previewPosition.z - offset
                );
                
                // 更新预览棋子颜色
                this.previewStone.material.color.set(
                    this.currentPlayer === 1 ? 0x000000 : 0xffffff
                );
                
                // 更新坐标显示
                document.getElementById('coordinates').textContent = 
                    `预览位置: (${this.previewPosition.x}, ${this.previewPosition.y}, ${this.previewPosition.z})`;
                
                // 更新输入框
                document.getElementById('x-input').value = this.previewPosition.x;
                document.getElementById('y-input').value = this.previewPosition.y;
                document.getElementById('z-input').value = this.previewPosition.z;
                document.getElementById('layer-x-input').value = this.previewPosition.x;
                document.getElementById('layer-z-input').value = this.previewPosition.z;
            }
            
            // 放置棋子
            placeStone(x, y, z) {
                if (!this.gameActive) return false;
                
                // 检查位置是否有效
                if (x < 0 || x >= this.boardSize || y < 0 || y >= this.boardSize || z < 0 || z >= this.boardSize) {
                    alert('坐标超出范围！有效范围：0-' + (this.boardSize - 1));
                    return false;
                }
                
                // 检查位置是否已有棋子
                if (this.board[x][y][z] !== 0) {
                    alert('该位置已有棋子！');
                    return false;
                }
                
                // 放置棋子
                this.board[x][y][z] = this.currentPlayer;
                
                // 渲染棋子
                this.renderStone(x, y, z);
                
                // 检查是否获胜
                if (this.checkWin(x, y, z)) {
                    this.gameActive = false;
                    const winner = this.currentPlayer === 1 ? '黑方' : '白方';
                    document.getElementById('status').textContent = `${winner}获胜！`;
                    this.updateUI();
                    return true;
                }
                
                // 切换玩家
                this.currentPlayer = 3 - this.currentPlayer;
                this.updateUI();
                this.updatePreview();
                
                // 如果是PvE模式且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
                
                return true;
            }
            
            // AI走棋
            aiMove() {
                if (!this.gameActive) return;
                
                // 更新状态显示
                document.getElementById('status').textContent = 'AI思考中...';
                
                // 使用setTimeout给UI一个更新的机会
                setTimeout(() => {
                    // 获取AI的最佳移动
                    const move = this.ai.getBestMove(this.board, this.boardSize);
                    
                    if (move) {
                        // 执行AI的移动
                        this.placeStone(move.x, move.y, move.z);
                        
                        // 更新预览位置
                        this.previewPosition = {x: move.x, y: move.y, z: move.z};
                        this.updatePreviewPosition();
                    }
                }, 100);
            }
            
            // 检查是否获胜
            checkWin(x, y, z) {
                const player = this.board[x][y][z];
                if (player === 0) return false;
                
                // 定义所有可能的方向向量（三维空间中的26个方向）
                const directions = [
                    // 轴向方向
                    {dx: 1, dy: 0, dz: 0}, {dx: -1, dy: 0, dz: 0}, // X轴
                    {dx: 0, dy: 1, dz: 0}, {dx: 0, dy: -1, dz: 0}, // Y轴
                    {dx: 0, dy: 0, dz: 1}, {dx: 0, dy: 0, dz: -1}, // Z轴
                    
                    // 平面对角线
                    {dx: 1, dy: 1, dz: 0}, {dx: -1, dy: -1, dz: 0},
                    {dx: 1, dy: -1, dz: 0}, {dx: -1, dy: 1, dz: 0},
                    {dx: 1, dy: 0, dz: 1}, {dx: -1, dy: 0, dz: -1},
                    {dx: 1, dy: 0, dz: -1}, {dx: -1, dy: 0, dz: 1},
                    {dx: 0, dy: 1, dz: 1}, {dx: 0, dy: -1, dz: -1},
                    {dx: 0, dy: 1, dz: -1}, {dx: 0, dy: -1, dz: 1},
                    
                    // 空间对角线
                    {dx: 1, dy: 1, dz: 1}, {dx: -1, dy: -1, dz: -1},
                    {dx: 1, dy: 1, dz: -1}, {dx: -1, dy: -1, dz: 1},
                    {dx: 1, dy: -1, dz: 1}, {dx: -1, dy: 1, dz: -1},
                    {dx: 1, dy: -1, dz: -1}, {dx: -1, dy: 1, dz: 1}
                ];
                
                // 检查每个方向
                for (const dir of directions) {
                    let count = 1; // 当前位置已经有一个棋子
                    
                    // 正向检查
                    let nx = x + dir.dx;
                    let ny = y + dir.dy;
                    let nz = z + dir.dz;
                    
                    while (nx >= 0 && nx < this.boardSize && 
                           ny >= 0 && ny < this.boardSize && 
                           nz >= 0 && nz < this.boardSize &&
                           this.board[nx][ny][nz] === player) {
                        count++;
                        nx += dir.dx;
                        ny += dir.dy;
                        nz += dir.dz;
                    }
                    
                    // 反向检查
                    nx = x - dir.dx;
                    ny = y - dir.dy;
                    nz = z - dir.dz;
                    
                    while (nx >= 0 && nx < this.boardSize && 
                           ny >= 0 && ny < this.boardSize && 
                           nz >= 0 && nz < this.boardSize &&
                           this.board[nx][ny][nz] === player) {
                        count++;
                        nx -= dir.dx;
                        ny -= dir.dy;
                        nz -= dir.dz;
                    }
                    
                    // 如果连成五个或以上，则获胜
                    if (count >= 5) {
                        this.highlightWinningLine(x, y, z, dir, count);
                        return true;
                    }
                }
                
                return false;
            }
            
            // 高亮显示获胜连线
            highlightWinningLine(x, y, z, dir, count) {
                const offset = (this.boardSize - 1) / 2;
                
                // 计算连线的起点和终点
                let startX = x;
                let startY = y;
                let startZ = z;
                
                // 反向找到连线的起点
                while (startX - dir.dx >= 0 && startX - dir.dx < this.boardSize &&
                       startY - dir.dy >= 0 && startY - dir.dy < this.boardSize &&
                       startZ - dir.dz >= 0 && startZ - dir.dz < this.boardSize &&
                       this.board[startX - dir.dx][startY - dir.dy][startZ - dir.dz] === this.board[x][y][z]) {
                    startX -= dir.dx;
                    startY -= dir.dy;
                    startZ -= dir.dz;
                }
                
                // 计算连线的终点
                let endX = startX + (count - 1) * dir.dx;
                let endY = startY + (count - 1) * dir.dy;
                let endZ = startZ + (count - 1) * dir.dz;
                
                // 创建连线
                const points = [];
                points.push(new THREE.Vector3(
                    startX - offset,
                    startY,
                    startZ - offset
                ));
                points.push(new THREE.Vector3(
                    endX - offset,
                    endY,
                    endZ - offset
                ));
                
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ 
                    color: 0xffd700, 
                    linewidth: 5 
                });
                
                this.winningLine = new THREE.Line(geometry, material);
                this.scene.add(this.winningLine);
            }
            
            // 渲染棋子
            renderStone(x, y, z) {
                const color = this.board[x][y][z];
                if (color === 0) return;
                
                // 移除可能已存在的棋子模型
                this.removeStoneModel(x, y, z);
                
                const offset = (this.boardSize - 1) / 2;
                
                // 创建棋子
                const geometry = new THREE.SphereGeometry(0.4, 16, 16);
                const material = new THREE.MeshStandardMaterial({ 
                    color: color === 1 ? 0x000000 : 0xffffff,
                    roughness: 0.7,
                    metalness: 0.1
                });
                
                const stone = new THREE.Mesh(geometry, material);
                stone.position.set(x - offset, y, z - offset);
                stone.userData = {x, y, z};
                this.stoneGroup.add(stone);
            }
            
            // 移除棋子模型
            removeStoneModel(x, y, z) {
                for (let i = this.stoneGroup.children.length - 1; i >= 0; i--) {
                    const stone = this.stoneGroup.children[i];
                    if (stone.userData.x === x && stone.userData.y === y && stone.userData.z === z) {
                        this.stoneGroup.remove(stone);
                        break;
                    }
                }
            }
            
            // 坐标输入落子
            placeByCoordinates() {
                const x = parseInt(document.getElementById('x-input').value);
                const y = parseInt(document.getElementById('y-input').value);
                const z = parseInt(document.getElementById('z-input').value);
                
                if (isNaN(x) || isNaN(y) || isNaN(z)) {
                    alert('请输入有效的坐标值！');
                    return;
                }
                
                if (this.placeStone(x, y, z)) {
                    // 更新预览位置
                    this.previewPosition = {x, y, z};
                    this.updatePreviewPosition();
                }
            }
            
            // 当前层落子
            placeOnCurrentLayer() {
                const x = parseInt(document.getElementById('layer-x-input').value);
                const z = parseInt(document.getElementById('layer-z-input').value);
                const y = this.currentLayer;
                
                if (isNaN(x) || isNaN(z)) {
                    alert('请输入有效的坐标值！');
                    return;
                }
                
                if (this.placeStone(x, y, z)) {
                    // 更新预览位置
                    this.previewPosition = {x, y, z};
                    this.updatePreviewPosition();
                }
            }
            
            // 切换落子模式
            setPlacementMode(mode) {
                this.placementMode = mode;
                
                // 更新UI
                const coordInput = document.getElementById('coord-input');
                const layerInput = document.getElementById('layer-input');
                const modeValue = document.getElementById('mode-value');
                
                if (mode === 'coord') {
                    coordInput.style.display = 'flex';
                    layerInput.style.display = 'none';
                    modeValue.textContent = '坐标输入';
                    
                    // 更新按钮状态
                    document.getElementById('mode-coord').classList.add('active');
                    document.getElementById('mode-layer').classList.remove('active');
                } else {
                    coordInput.style.display = 'none';
                    layerInput.style.display = 'block';
                    modeValue.textContent = '当前层';
                    
                    // 更新按钮状态
                    document.getElementById('mode-coord').classList.remove('active');
                    document.getElementById('mode-layer').classList.add('active');
                }
            }
            
            // 更新预览
            updatePreview() {
                this.updatePreviewPosition();
            }
            
            // 微调预览位置
            adjustPreview(dx, dy, dz) {
                this.previewPosition.x = Math.max(0, Math.min(this.boardSize - 1, this.previewPosition.x + dx));
                this.previewPosition.y = Math.max(0, Math.min(this.boardSize - 1, this.previewPosition.y + dy));
                this.previewPosition.z = Math.max(0, Math.min(this.boardSize - 1, this.previewPosition.z + dz));
                
                this.updatePreview();
            }
            
            // 设置棋盘大小
            setBoardSize(size) {
                if (size < 5 || size > 21) {
                    alert('棋盘大小必须在5到21之间！');
                    return;
                }
                
                this.boardSize = size;
                this.currentLayer = Math.floor(this.boardSize / 2);
                
                // 重置预览位置到中心
                this.previewPosition = {
                    x: Math.floor(this.boardSize / 2),
                    y: Math.floor(this.boardSize / 2),
                    z: Math.floor(this.boardSize / 2)
                };
                
                this.createBoard();
                this.updateUI();
                this.updatePreview();
            }
            
            // 切换游戏模式
            setGameMode(mode) {
                this.gameMode = mode;
                this.updateUI();
                
                // 如果切换到PvE模式且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 设置AI难度
            setAIDifficulty(difficulty) {
                this.aiDifficulty = difficulty;
                this.ai = new GomokuAI(this.aiDifficulty, this.playerColor);
            }
            
            // 设置玩家颜色
            setPlayerColor(color) {
                this.playerColor = color === 'black' ? 1 : 2;
                this.ai = new GomokuAI(this.aiDifficulty, this.playerColor);
                
                // 如果游戏正在进行中且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 切换拖动模式
            toggleDragMode() {
                this.dragEnabled = !this.dragEnabled;
                this.controls.enablePan = this.dragEnabled;
                document.getElementById('toggle-drag').textContent = 
                    `拖动模式: ${this.dragEnabled ? '开启' : '关闭'}`;
            }
            
            // 更新UI
            updateUI() {
                // 更新当前玩家显示
                const playerIndicator = document.querySelector('#current-player .player-indicator');
                const playerText = document.querySelector('#current-player span');
                
                if (this.currentPlayer === 1) {
                    playerIndicator.className = 'player-indicator black';
                    playerText.textContent = '当前玩家: 黑方';
                } else {
                    playerIndicator.className = 'player-indicator white';
                    playerText.textContent = '当前玩家: 白方';
                }
                
                // 更新游戏状态
                const statusElement = document.getElementById('status');
                if (this.gameActive) {
                    if (this.gameMode === 'pve') {
                        if ((this.playerColor === 1 && this.currentPlayer === 1) || 
                            (this.playerColor === 2 && this.currentPlayer === 2)) {
                            statusElement.textContent = '玩家回合';
                        } else {
                            statusElement.textContent = 'AI回合';
                        }
                    } else {
                        statusElement.textContent = '游戏进行中';
                    }
                    statusElement.style.color = '#2ecc71';
                } else {
                    statusElement.style.color = '#e74c3c';
                }
                
                // 更新输入框范围
                const maxCoord = this.boardSize - 1;
                document.getElementById('x-input').max = maxCoord;
                document.getElementById('y-input').max = maxCoord;
                document.getElementById('z-input').max = maxCoord;
                document.getElementById('layer-x-input').max = maxCoord;
                document.getElementById('layer-z-input').max = maxCoord;
            }
            
            // 新游戏
            newGame() {
                this.createBoard();
                this.currentPlayer = 1;
                this.gameActive = true;
                
                this.updateUI();
                this.updatePreview();
            }
            
            // 跳过回合
            passTurn() {
                if (!this.gameActive) return;
                
                this.currentPlayer = 3 - this.currentPlayer;
                this.updateUI();
                this.updatePreview();
                
                // 如果是PvE模式且轮到AI，让AI走棋
                if (this.gameActive && this.gameMode === 'pve' && 
                    ((this.playerColor === 1 && this.currentPlayer === 2) || 
                     (this.playerColor === 2 && this.currentPlayer === 1))) {
                    setTimeout(() => this.aiMove(), 500);
                }
            }
            
            // 认输
            resign() {
                if (!this.gameActive) return;
                
                this.gameActive = false;
                const winner = this.currentPlayer === 1 ? '白方' : '黑方';
                document.getElementById('status').textContent = `${winner}获胜！`;
                this.updateUI();
            }
            
            // 重置视角
            resetView() {
                this.camera.position.set(20, 15, 20);
                this.controls.reset();
            }
            
            // 设置事件监听器
            setupEventListeners() {
                // 游戏模式选择
                document.getElementById('game-mode').addEventListener('change', (e) => {
                    this.setGameMode(e.target.value);
                });
                
                // AI难度选择
                document.getElementById('ai-difficulty').addEventListener('change', (e) => {
                    this.setAIDifficulty(e.target.value);
                });
                
                // 玩家颜色选择
                document.getElementById('player-color').addEventListener('change', (e) => {
                    this.setPlayerColor(e.target.value);
                });
                
                // 落子按钮
                document.getElementById('place-btn').addEventListener('click', () => this.placeByCoordinates());
                document.getElementById('layer-place-btn').addEventListener('click', () => this.placeOnCurrentLayer());
                
                // 落子模式切换
                document.getElementById('mode-coord').addEventListener('click', () => this.setPlacementMode('coord'));
                document.getElementById('mode-layer').addEventListener('click', () => this.setPlacementMode('layer'));
                
                // 层控制
                const layerSlider = document.getElementById('layer-slider');
                layerSlider.addEventListener('input', (e) => {
                    this.currentLayer = parseInt(e.target.value);
                    this.updateLayerIndicator();
                    this.previewPosition.y = this.currentLayer;
                    this.updatePreview();
                });
                
                document.getElementById('prev-layer').addEventListener('click', () => {
                    if (this.currentLayer > 0) {
                        this.currentLayer--;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                
                document.getElementById('next-layer').addEventListener('click', () => {
                    if (this.currentLayer < this.boardSize - 1) {
                        this.currentLayer++;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                
                // 棋盘大小设置
                document.getElementById('set-board-size').addEventListener('click', () => {
                    const size = parseInt(document.getElementById('board-size-input').value);
                    this.setBoardSize(size);
                });
                
                // 微调按钮
                document.getElementById('key-up').addEventListener('click', () => this.adjustPreview(0, 1, 0));
                document.getElementById('key-down').addEventListener('click', () => this.adjustPreview(0, -1, 0));
                document.getElementById('key-left').addEventListener('click', () => this.adjustPreview(-1, 0, 0));
                document.getElementById('key-right').addEventListener('click', () => this.adjustPreview(1, 0, 0));
                document.getElementById('key-front').addEventListener('click', () => this.adjustPreview(0, 0, 1));
                document.getElementById('key-back').addEventListener('click', () => this.adjustPreview(0, 0, -1));
                document.getElementById('key-layer-up').addEventListener('click', () => {
                    if (this.currentLayer < this.boardSize - 1) {
                        this.currentLayer++;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                document.getElementById('key-layer-down').addEventListener('click', () => {
                    if (this.currentLayer > 0) {
                        this.currentLayer--;
                        document.getElementById('layer-slider').value = this.currentLayer;
                        this.updateLayerIndicator();
                        this.previewPosition.y = this.currentLayer;
                        this.updatePreview();
                    }
                });
                document.getElementById('key-center').addEventListener('click', () => {
                    if (this.placementMode === 'coord') {
                        this.placeByCoordinates();
                    } else {
                        this.placeOnCurrentLayer();
                    }
                });
                
                // 键盘控制
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case 'ArrowUp':
                            e.preventDefault();
                            this.adjustPreview(0, 1, 0);
                            break;
                        case 'ArrowDown':
                            e.preventDefault();
                            this.adjustPreview(0, -1, 0);
                            break;
                        case 'ArrowLeft':
                            e.preventDefault();
                            this.adjustPreview(-1, 0, 0);
                            break;
                        case 'ArrowRight':
                            e.preventDefault();
                            this.adjustPreview(1, 0, 0);
                            break;
                        case 'PageUp':
                            e.preventDefault();
                            this.adjustPreview(0, 0, 1);
                            break;
                        case 'PageDown':
                            e.preventDefault();
                            this.adjustPreview(0, 0, -1);
                            break;
                        case 'Enter':
                            e.preventDefault();
                            if (this.placementMode === 'coord') {
                                this.placeByCoordinates();
                            } else {
                                this.placeOnCurrentLayer();
                            }
                            break;
                    }
                });
                
                // UI控制
                document.getElementById('new-game').addEventListener('click', () => this.newGame());
                document.getElementById('pass-turn').addEventListener('click', () => this.passTurn());
                document.getElementById('resign').addEventListener('click', () => this.resign());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                document.getElementById('toggle-drag').addEventListener('click', () => this.toggleDragMode());
                
                // 输入框回车事件
                document.getElementById('x-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeByCoordinates();
                });
                document.getElementById('y-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeByCoordinates();
                });
                document.getElementById('z-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeByCoordinates();
                });
                document.getElementById('layer-x-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeOnCurrentLayer();
                });
                document.getElementById('layer-z-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.placeOnCurrentLayer();
                });
                document.getElementById('board-size-input').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const size = parseInt(document.getElementById('board-size-input').value);
                        this.setBoardSize(size);
                    }
                });
            }
            
            // 窗口大小调整
            onWindowResize() {
                this.camera.aspect = (window.innerWidth * 0.75) / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth * 0.75, window.innerHeight);
            }
            
            // 动画循环
            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // 初始化游戏
        window.addEventListener('DOMContentLoaded', () => {
            const game = new ThreeDGomoku();
        });
    </script>
</body>
</html>